import tkinter as tk
from tkinter import ttk, messagebox
from datetime import datetime, timezone
# Import standard library for Time Zone handling
from zoneinfo import ZoneInfo, available_timezones

class TimeDecoderApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Time Decode - Simple")
        self.root.geometry("600x520") # Increased height for new fields
        
        style = ttk.Style()
        style.configure("TLabel", font=("Helvetica", 10))
        style.configure("TButton", font=("Helvetica", 10, "bold"))
        style.configure("Result.TLabel", font=("Consolas", 12)) 

        main_frame = ttk.Frame(root, padding="20")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # 1. Input Timestamp
        ttk.Label(main_frame, text="Input Timestamp:").pack(anchor=tk.W)
        self.input_var = tk.StringVar()
        self.entry_input = ttk.Entry(main_frame, textvariable=self.input_var, width=50, font=("Consolas", 11))
        self.entry_input.pack(fill=tk.X, pady=(5, 15))

        # 2. Source Format Selection
        ttk.Label(main_frame, text="Source Format:").pack(anchor=tk.W)
        self.format_var = tk.StringVar(value="Unix Hex 32-bit Big Endian")
        formats = [
            "Unix Hex 32-bit Big Endian",
            "Unix Hex 32-bit Little Endian",
            "Unix Milliseconds Hex",
            "Unix Milliseconds (Decimal)",
            "Windows FILETIME Big Endian",
            "Windows FILETIME Little Endian"
        ]
        self.combo_format = ttk.Combobox(main_frame, textvariable=self.format_var, values=formats, state="readonly")
        self.combo_format.pack(fill=tk.X, pady=(5, 15))

        # 3. Target Timezone Selection (New Feature)
        ttk.Label(main_frame, text="Optional Target Timezone:").pack(anchor=tk.W)
        
        # Get valid timezones from OS, sort them, and set a default
        self.available_zones = sorted(list(available_timezones()))
        
        # Default to something common if available, else first in list
        default_tz = "America/Los_Angeles" if "America/Los_Angeles" in self.available_zones else self.available_zones[0]
        
        self.tz_var = tk.StringVar(value=default_tz)
        self.combo_tz = ttk.Combobox(main_frame, textvariable=self.tz_var, values=self.available_zones, height=10)
        self.combo_tz.pack(fill=tk.X, pady=(5, 20))

        # 4. Action Button
        self.btn_convert = ttk.Button(main_frame, text="CONVERT", command=self.convert_time)
        self.btn_convert.pack(fill=tk.X, pady=(0, 20))

        # 5. Output Section
        self.lbl_utc = ttk.Label(main_frame, text="UTC Time:    --", style="Result.TLabel")
        self.lbl_utc.pack(anchor=tk.W, pady=5)

        self.lbl_local = ttk.Label(main_frame, text="Local Time:  --", style="Result.TLabel")
        self.lbl_local.pack(anchor=tk.W, pady=5)

        self.lbl_target = ttk.Label(main_frame, text="Target Time: --", style="Result.TLabel", foreground="#007AFF") # Highlighted color
        self.lbl_target.pack(anchor=tk.W, pady=5)

    def get_unix_timestamp(self, input_str, fmt):
        clean_input = input_str.strip().replace("0x", "").replace(" ", "").replace(":", "")
        if len(clean_input) % 2 != 0: clean_input = "0" + clean_input

        try:
            if fmt == "Unix Hex 32-bit Big Endian":
                return float(int(clean_input, 16))
            elif fmt == "Unix Hex 32-bit Little Endian":
                byte_vals = bytes.fromhex(clean_input)
                return float(int(byte_vals[::-1].hex(), 16))
            elif fmt == "Unix Milliseconds Hex":
                return int(clean_input, 16) / 1000.0
            elif fmt == "Unix Milliseconds (Decimal)":
                return int(input_str.strip()) / 1000.0
            elif fmt == "Windows FILETIME Big Endian":
                return self.windows_filetime_to_unix(int(clean_input, 16))
            elif fmt == "Windows FILETIME Little Endian":
                byte_vals = bytes.fromhex(clean_input)
                return self.windows_filetime_to_unix(int(byte_vals[::-1].hex(), 16))
            else:
                raise ValueError(f"Unknown format: {fmt}")
        except Exception as e:
            print(f"DEBUG ERROR: {e}")
            raise e

    def windows_filetime_to_unix(self, filetime_val):
        return (filetime_val - 116444736000000000) / 10_000_000

    def convert_time(self):
        input_val = self.input_var.get()
        fmt_selection = self.format_var.get()
        target_tz_name = self.tz_var.get()

        if not input_val:
            messagebox.showwarning("Warning", "Please enter a timestamp value.")
            return

        try:
            # 1. Base Conversion to Epoch
            epoch_seconds = self.get_unix_timestamp(input_val, fmt_selection)

            # 2. Create Time Objects
            dt_utc = datetime.fromtimestamp(epoch_seconds, timezone.utc)
            dt_local = datetime.fromtimestamp(epoch_seconds).astimezone()
            
            # 3. Create Custom Target Time Object
            try:
                if target_tz_name in self.available_zones:
                    dt_target = dt_utc.astimezone(ZoneInfo(target_tz_name))
                    target_str = dt_target.strftime('%Y-%m-%d %H:%M:%S.%f %Z')
                else:
                    target_str = "Invalid Timezone Selected"
            except Exception as e:
                target_str = "Timezone Error"

            # 4. Display
            self.lbl_utc.config(text=f"UTC Time:    {dt_utc.strftime('%Y-%m-%d %H:%M:%S.%f')}")
            self.lbl_local.config(text=f"Local Time:  {dt_local.strftime('%Y-%m-%d %H:%M:%S.%f %Z')}")
            self.lbl_target.config(text=f"Target Time: {target_str}")

        except Exception as e:
            messagebox.showerror("Error", f"Failed to decode.\n{str(e)}")

if __name__ == "__main__":
    root = tk.Tk()
    app = TimeDecoderApp(root)
    root.mainloop()