import tkinter as tk
from tkinter import ttk, messagebox, scrolledtext
from datetime import datetime, timezone
from zoneinfo import ZoneInfo, available_timezones

class TimeDecoderApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Time Decode - Simple")
        self.root.geometry("600x580") # Increased height for new button
        
        style = ttk.Style()
        style.configure("TLabel", font=("Helvetica", 10))
        style.configure("TButton", font=("Helvetica", 10, "bold"))
        style.configure("Result.TLabel", font=("Consolas", 12)) 

        main_frame = ttk.Frame(root, padding="20")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # 1. Input Timestamp
        ttk.Label(main_frame, text="Input Timestamp:").pack(anchor=tk.W)
        self.input_var = tk.StringVar()
        self.entry_input = ttk.Entry(main_frame, textvariable=self.input_var, width=50, font=("Consolas", 11))
        self.entry_input.pack(fill=tk.X, pady=(5, 15))

        # 2. Source Format Selection
        ttk.Label(main_frame, text="Source Format:").pack(anchor=tk.W)
        self.format_var = tk.StringVar(value="Unix Hex 32-bit Big Endian")
        
        # DEFINED FORMATS LIST (Used for dropdown AND guessing)
        self.formats = [
            "Unix Seconds (Decimal)",  # <--- NEW ADDITION
            "Unix Hex 32-bit Big Endian",
            "Unix Hex 32-bit Little Endian",
            "Unix Milliseconds Hex",
            "Unix Milliseconds (Decimal)",
            "Windows FILETIME Big Endian",
            "Windows FILETIME Little Endian"
        ]
        
        self.combo_format = ttk.Combobox(main_frame, textvariable=self.format_var, values=self.formats, state="readonly")
        self.combo_format.pack(fill=tk.X, pady=(5, 15))

        # 3. Target Timezone Selection
        ttk.Label(main_frame, text="Optional Target Timezone:").pack(anchor=tk.W)
        self.available_zones = sorted(list(available_timezones()))
        default_tz = "America/Los_Angeles" if "America/Los_Angeles" in self.available_zones else self.available_zones[0]
        self.tz_var = tk.StringVar(value=default_tz)
        self.combo_tz = ttk.Combobox(main_frame, textvariable=self.tz_var, values=self.available_zones, height=10)
        self.combo_tz.pack(fill=tk.X, pady=(5, 20))

        # 4. Action Buttons
        btn_frame = ttk.Frame(main_frame)
        btn_frame.pack(fill=tk.X, pady=(0, 20))
        
        # Standard Convert
        self.btn_convert = ttk.Button(btn_frame, text="CONVERT (Single)", command=self.convert_time)
        self.btn_convert.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 5))

        # Guess / Check All
        self.btn_guess = ttk.Button(btn_frame, text="GUESS / CHECK ALL", command=self.guess_all_formats)
        self.btn_guess.pack(side=tk.RIGHT, fill=tk.X, expand=True, padx=(5, 0))

        # 5. Output Section
        self.lbl_utc = ttk.Label(main_frame, text="UTC Time:    --", style="Result.TLabel")
        self.lbl_utc.pack(anchor=tk.W, pady=5)

        self.lbl_local = ttk.Label(main_frame, text="Local Time:  --", style="Result.TLabel")
        self.lbl_local.pack(anchor=tk.W, pady=5)

        self.lbl_target = ttk.Label(main_frame, text="Target Time: --", style="Result.TLabel", foreground="#007AFF")
        self.lbl_target.pack(anchor=tk.W, pady=5)

    def get_unix_timestamp(self, input_str, fmt):
        clean_input = input_str.strip().replace("0x", "").replace(" ", "").replace(":", "")
        # Pad odd-length hex strings
        if len(clean_input) % 2 != 0: clean_input = "0" + clean_input

        try:
            if fmt == "Unix Seconds (Decimal)":
                return float(int(input_str.strip()))
            
            elif fmt == "Unix Hex 32-bit Big Endian":
                return float(int(clean_input, 16))
            
            elif fmt == "Unix Hex 32-bit Little Endian":
                byte_vals = bytes.fromhex(clean_input)
                return float(int(byte_vals[::-1].hex(), 16))
            
            elif fmt == "Unix Milliseconds Hex":
                return int(clean_input, 16) / 1000.0
            
            elif fmt == "Unix Milliseconds (Decimal)":
                return int(input_str.strip()) / 1000.0
            
            elif fmt == "Windows FILETIME Big Endian":
                return self.windows_filetime_to_unix(int(clean_input, 16))
            
            elif fmt == "Windows FILETIME Little Endian":
                byte_vals = bytes.fromhex(clean_input)
                return self.windows_filetime_to_unix(int(byte_vals[::-1].hex(), 16))
            
            else:
                raise ValueError(f"Unknown format: {fmt}")
        except Exception:
            # Re-raise so the caller knows it failed
            raise ValueError(f"Conversion failed for {fmt}")

    def windows_filetime_to_unix(self, filetime_val):
        # 11,644,473,600 seconds from 1601 to 1970
        return (filetime_val - 116444736000000000) / 10_000_000

    def convert_time(self):
        self._perform_conversion(self.format_var.get())

    def _perform_conversion(self, fmt_selection):
        input_val = self.input_var.get()
        target_tz_name = self.tz_var.get()

        if not input_val:
            messagebox.showwarning("Warning", "Please enter a timestamp value.")
            return

        try:
            epoch_seconds = self.get_unix_timestamp(input_val, fmt_selection)

            # Sanity check for extremely large/small years to avoid crashing datetime
            if epoch_seconds > 32503680000 or epoch_seconds < -30610224000: 
                 raise ValueError("Resulting date is out of supported bounds (Year 1000-3000)")

            dt_utc = datetime.fromtimestamp(epoch_seconds, timezone.utc)
            dt_local = datetime.fromtimestamp(epoch_seconds).astimezone()
            
            try:
                if target_tz_name in self.available_zones:
                    dt_target = dt_utc.astimezone(ZoneInfo(target_tz_name))
                    target_str = dt_target.strftime('%Y-%m-%d %H:%M:%S.%f %Z')
                else:
                    target_str = "Invalid Timezone Selected"
            except Exception:
                target_str = "Timezone Error"

            # Display
            self.lbl_utc.config(text=f"UTC Time:    {dt_utc.strftime('%Y-%m-%d %H:%M:%S.%f')}")
            self.lbl_local.config(text=f"Local Time:  {dt_local.strftime('%Y-%m-%d %H:%M:%S.%f %Z')}")
            self.lbl_target.config(text=f"Target Time: {target_str}")
        
        except Exception as e:
            messagebox.showerror("Error", f"Failed to decode.\n{str(e)}")

    def guess_all_formats(self):
        input_val = self.input_var.get()
        if not input_val:
            messagebox.showwarning("Warning", "Please enter a timestamp value to guess.")
            return

        valid_results = []

        # Iterate through all known formats
        for fmt in self.formats:
            try:
                epoch = self.get_unix_timestamp(input_val, fmt)
                
                # FILTER: Only show "Human Readable" dates
                # We define this as dates between Year 1970 and Year 2040
                # 1970 = 0, 2040 = approx 2.2 billion seconds
                if 0 <= epoch <= 2208988800:
                    dt_obj = datetime.fromtimestamp(epoch, timezone.utc)
                    valid_results.append((fmt, dt_obj.strftime('%Y-%m-%d %H:%M:%S UTC')))
            except:
                continue

        # Show results in a new window
        self.show_guess_results(valid_results)

    def show_guess_results(self, results):
        # Create a popup window
        top = tk.Toplevel(self.root)
        top.title("Guess Results")
        top.geometry("600x400")

        lbl = ttk.Label(top, text=f"Found {len(results)} potential match(es) (Years 1970-2040):", font=("Helvetica", 10, "bold"))
        lbl.pack(pady=10)

        # Scrollable text area
        text_area = scrolledtext.ScrolledText(top, width=70, height=15, font=("Consolas", 11))
        text_area.pack(padx=10, pady=5)

        if not results:
            text_area.insert(tk.END, "No valid timestamps found for this input.")
        else:
            for fmt, time_str in results:
                text_area.insert(tk.END, f"Format: {fmt}\nResult: {time_str}\n{'-'*50}\n")
        
        text_area.configure(state='disabled') # Make read-only

if __name__ == "__main__":
    root = tk.Tk()
    app = TimeDecoderApp(root)
    root.mainloop()